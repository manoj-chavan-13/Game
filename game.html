<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Pulse Synthesizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: #050505;
            overflow: hidden;
            /* Prevent scrolling on mobile */
            touch-action: none;
        }

        .font-cyber {
            font-family: 'Orbitron', sans-serif;
        }

        /* Neon Glow Effects */
        .neon-text-blue {
            text-shadow: 0 0 5px #00f3ff, 0 0 10px #00f3ff, 0 0 20px #00f3ff;
        }

        .neon-text-pink {
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 20px #ff00ff;
        }

        .neon-box {
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2), inset 0 0 20px rgba(0, 243, 255, 0.05);
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        /* Piano Keys */
        .key {
            transition: all 0.1s ease;
            cursor: pointer;
            position: relative;
            z-index: 10;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .white-key {
            background: linear-gradient(180deg, #e0e0e0 0%, #ffffff 100%);
            border-radius: 0 0 6px 6px;
            box-shadow: inset 0 1px 0px #fff, inset 0 -5px 0px rgba(0, 0, 0, 0.2), 0 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .white-key.active {
            background: #00f3ff;
            box-shadow: 0 0 15px #00f3ff, 0 0 30px #00f3ff;
            transform: translateY(2px);
            z-index: 12;
        }

        .black-key {
            background: linear-gradient(180deg, #333 0%, #000 100%);
            border-radius: 0 0 4px 4px;
            box-shadow: inset 0 1px 0px #444, inset 0 -2px 0px rgba(255, 255, 255, 0.1), 0 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 20;
        }

        .black-key.active {
            background: #ff00ff;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff;
            transform: translateY(2px);
        }

        /* Control Knobs/Sliders */
        .cyber-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #333;
            outline: none;
            border-radius: 2px;
        }

        .cyber-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00f3ff;
            box-shadow: 0 0 10px #00f3ff;
            cursor: pointer;
            margin-top: -6px;
            /* center thumb */
            position: relative;
            z-index: 2;
        }

        .cyber-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #1a1a1a;
            border-radius: 2px;
            border: 1px solid #333;
        }

        /* Custom scrollbar for key labels if needed */
        .key-label {
            pointer-events: none;
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }

        .black-key .key-label {
            color: rgba(255, 255, 255, 0.5);
            bottom: 6px;
        }

        /* Visualizer Canvas */
        #visualizer {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>

<body class="h-screen flex flex-col items-center justify-between p-4 md:p-8 bg-[#050505] text-white">

    <!-- Header & Visualizer -->
    <div class="w-full max-w-5xl flex flex-col gap-4 mb-4 relative z-10">
        <header class="flex justify-between items-end border-b border-[#00f3ff33] pb-4">
            <div>
                <h1 class="font-cyber text-4xl md:text-5xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-[#00f3ff] to-[#ff00ff] neon-text-blue"
                    style="filter: drop-shadow(0 0 5px rgba(0,243,255,0.5));">
                    NEON<span class="text-white">SYNTH</span>
                </h1>
                <p class="text-[#00f3ff] text-xs tracking-[0.3em] font-bold mt-1 opacity-70">PROFESSIONAL AUDIO ENGINE
                    // V.1.0</p>
            </div>
            <div class="hidden md:block text-right">
                <div id="status-indicator" class="flex items-center gap-2 justify-end">
                    <span class="w-2 h-2 rounded-full bg-red-500 animate-pulse shadow-[0_0_10px_red]"
                        id="power-light"></span>
                    <span class="text-xs font-mono text-gray-400" id="power-text">STANDBY</span>
                </div>
                <div class="text-[10px] text-gray-500 font-mono mt-1">CPU: <span id="cpu-load">0</span>%</div>
            </div>
        </header>

        <!-- Main Display / Visualizer -->
        <div class="neon-box rounded-lg h-32 md:h-48 bg-black/60 relative overflow-hidden group">
            <canvas id="visualizer"></canvas>

            <!-- Grid Overlay -->
            <div
                class="absolute inset-0 bg-[linear-gradient(rgba(0,243,255,0.05)_1px,transparent_1px),linear-gradient(90deg,rgba(0,243,255,0.05)_1px,transparent_1px)] bg-[size:20px_20px] pointer-events-none">
            </div>

            <!-- "Screen" Reflection -->
            <div class="absolute inset-0 bg-gradient-to-br from-white/5 to-transparent pointer-events-none"></div>

            <!-- Start Overlay -->
            <div id="start-overlay"
                class="absolute inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm z-20 transition-opacity duration-500">
                <button id="start-btn"
                    class="font-cyber px-8 py-3 bg-transparent border-2 border-[#00f3ff] text-[#00f3ff] hover:bg-[#00f3ff] hover:text-black hover:shadow-[0_0_20px_#00f3ff] transition-all duration-300 rounded uppercase font-bold text-xl tracking-widest">
                    Initialize System
                </button>
            </div>
        </div>
    </div>

    <!-- Controls Dashboard -->
    <div class="w-full max-w-5xl grid grid-cols-1 md:grid-cols-12 gap-4 mb-4 z-10">

        <!-- Waveform Selector -->
        <div class="neon-box p-4 rounded bg-black/40 md:col-span-4 flex flex-col justify-between">
            <h3
                class="text-[#ff00ff] text-xs tracking-widest font-bold mb-3 uppercase border-b border-[#ff00ff33] pb-1">
                Oscillator Shape</h3>
            <div class="flex justify-between gap-2">
                <button
                    class="wave-btn flex-1 py-2 rounded border border-[#333] hover:border-[#00f3ff] text-gray-400 hover:text-[#00f3ff] text-xs font-bold transition-all bg-black/50 active-wave"
                    data-wave="sine">SINE</button>
                <button
                    class="wave-btn flex-1 py-2 rounded border border-[#333] hover:border-[#00f3ff] text-gray-400 hover:text-[#00f3ff] text-xs font-bold transition-all bg-black/50"
                    data-wave="triangle">TRI</button>
                <button
                    class="wave-btn flex-1 py-2 rounded border border-[#333] hover:border-[#00f3ff] text-gray-400 hover:text-[#00f3ff] text-xs font-bold transition-all bg-black/50"
                    data-wave="sawtooth">SAW</button>
                <button
                    class="wave-btn flex-1 py-2 rounded border border-[#333] hover:border-[#00f3ff] text-gray-400 hover:text-[#00f3ff] text-xs font-bold transition-all bg-black/50"
                    data-wave="square">SQR</button>
            </div>
        </div>

        <!-- Master Volume -->
        <div class="neon-box p-4 rounded bg-black/40 md:col-span-4 flex flex-col justify-between">
            <div class="flex justify-between items-center border-b border-[#00f3ff33] pb-1 mb-3">
                <h3 class="text-[#00f3ff] text-xs tracking-widest font-bold uppercase">Master Gain</h3>
                <span id="vol-display" class="text-[#00f3ff] text-xs font-mono">75%</span>
            </div>
            <input type="range" id="volume-slider" min="0" max="100" value="75" class="cyber-slider">
        </div>

        <!-- Effects/Info -->
        <div class="neon-box p-4 rounded bg-black/40 md:col-span-4 flex flex-col justify-center">
            <div class="flex justify-between items-center text-xs text-gray-400 font-mono mb-1">
                <span>SUSTAIN</span>
                <span class="text-[#ff00ff]">ON</span>
            </div>
            <div class="w-full bg-[#111] h-1 rounded overflow-hidden mb-3">
                <div class="bg-[#ff00ff] w-full h-full shadow-[0_0_5px_#ff00ff]"></div>
            </div>
            <div class="text-[10px] text-gray-500 text-center uppercase tracking-wider">
                Use Keyboard <span class="text-white font-bold">A-K</span> and <span
                    class="text-white font-bold">W-U</span>
            </div>
        </div>
    </div>

    <!-- Piano Bed -->
    <div class="w-full max-w-5xl relative z-10 flex-grow flex items-end justify-center pb-2">
        <div
            class="relative w-full h-48 md:h-64 rounded-b-lg flex justify-center bg-[#111] p-1 shadow-[0_10px_50px_rgba(0,0,0,0.5)] border-t-4 border-[#333]">
            <!-- Decorative strip -->
            <div
                class="absolute top-[-4px] left-0 w-full h-1 bg-gradient-to-r from-[#00f3ff] via-[#ff00ff] to-[#00f3ff] opacity-50">
            </div>

            <div id="piano-container" class="relative flex h-full w-full max-w-4xl mx-auto">
                <!-- Keys will be generated by JS -->
            </div>
        </div>
    </div>

    <!-- Background Grid Effect -->
    <div class="fixed inset-0 z-0 pointer-events-none perspective-[1000px]">
        <div
            class="absolute bottom-0 w-full h-[50vh] bg-[linear-gradient(to_bottom,transparent_0%,rgba(0,243,255,0.03)_100%)] transform rotate-x-[60deg] origin-bottom scale-[2]">
        </div>
        <div class="absolute inset-0 bg-[radial-gradient(circle_at_center,rgba(5,5,5,0)_0%,rgba(5,5,5,1)_100%)]"></div>
    </div>

    <script>
        /**
         * Neon Synth Audio Engine
         * Professional polyphonic synthesizer using Web Audio API
         */

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let masterGainNode;
        let analyser;
        let oscillatorType = 'sine';
        const activeOscillators = {}; // Map note frequencies to oscillator nodes

        // Define frequency map for a standard octave (C4 to E5)
        // Key mapping: Z X C V B N M , . / (lower) and A S D F G H J K L ; ' (upper)
        // We will implement a versatile range suited for standard typing

        const noteFrequencies = {
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63,
            'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00,
            'A#4': 466.16, 'B4': 493.88, 'C5': 523.25, 'C#5': 554.37, 'D5': 587.33,
            'D#5': 622.25, 'E5': 659.25, 'F5': 698.46
        };

        // Layout Config: White keys and Black keys
        // We render them procedurally to manage the layout logic easily
        const pianoLayout = [
            { note: 'C4', type: 'white', keyBind: 'a', label: 'A' },
            { note: 'C#4', type: 'black', keyBind: 'w', label: 'W' },
            { note: 'D4', type: 'white', keyBind: 's', label: 'S' },
            { note: 'D#4', type: 'black', keyBind: 'e', label: 'E' },
            { note: 'E4', type: 'white', keyBind: 'd', label: 'D' },
            { note: 'F4', type: 'white', keyBind: 'f', label: 'F' },
            { note: 'F#4', type: 'black', keyBind: 't', label: 'T' },
            { note: 'G4', type: 'white', keyBind: 'g', label: 'G' },
            { note: 'G#4', type: 'black', keyBind: 'y', label: 'Y' },
            { note: 'A4', type: 'white', keyBind: 'h', label: 'H' },
            { note: 'A#4', type: 'black', keyBind: 'u', label: 'U' },
            { note: 'B4', type: 'white', keyBind: 'j', label: 'J' },
            { note: 'C5', type: 'white', keyBind: 'k', label: 'K' },
            { note: 'C#5', type: 'black', keyBind: 'o', label: 'O' },
            { note: 'D5', type: 'white', keyBind: 'l', label: 'L' },
            { note: 'D#5', type: 'black', keyBind: 'p', label: 'P' },
            { note: 'E5', type: 'white', keyBind: ';', label: ';' }
        ];

        // --- Initialization ---

        const startBtn = document.getElementById('start-btn');
        const startOverlay = document.getElementById('start-overlay');
        const powerLight = document.getElementById('power-light');
        const powerText = document.getElementById('power-text');

        startBtn.addEventListener('click', initAudio);

        function initAudio() {
            if (audioCtx) return;

            audioCtx = new AudioContext();

            // Master Gain (Volume)
            masterGainNode = audioCtx.createGain();
            masterGainNode.gain.value = 0.5; // Default volume
            masterGainNode.connect(audioCtx.destination);

            // Analyser for Visuals
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            masterGainNode.connect(analyser); // Connect gain to analyser, analyser is already implicitly connected to destination via the previous line? No, we need to chain.
            // Correct chain: Sources -> LocalGain -> MasterGain -> Analyser -> Destination
            masterGainNode.disconnect();
            masterGainNode.connect(analyser);
            analyser.connect(audioCtx.destination);

            // UI Updates
            startOverlay.style.opacity = '0';
            setTimeout(() => startOverlay.style.display = 'none', 500);

            powerLight.classList.remove('bg-red-500', 'shadow-[0_0_10px_red]');
            powerLight.classList.add('bg-[#00f3ff]', 'shadow-[0_0_10px_#00f3ff]');
            powerText.innerText = "ONLINE";
            powerText.classList.replace('text-gray-400', 'text-[#00f3ff]');

            // Start Visualizer
            drawVisualizer();
        }

        // --- Synth Logic ---

        function playNote(note) {
            if (!audioCtx) return;
            if (activeOscillators[note]) return; // Already playing

            const freq = noteFrequencies[note];

            // Oscillator
            const osc = audioCtx.createOscillator();
            osc.type = oscillatorType;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

            // Envelope (Gain for this specific note)
            const noteGain = audioCtx.createGain();

            // Wiring
            osc.connect(noteGain);
            noteGain.connect(masterGainNode);

            // ADSR Envelope Settings
            const attackTime = 0.05;
            const decayTime = 0.1;
            const sustainLevel = 0.7;

            // Attack
            noteGain.gain.setValueAtTime(0, audioCtx.currentTime);
            noteGain.gain.linearRampToValueAtTime(1, audioCtx.currentTime + attackTime);
            // Decay to Sustain
            noteGain.gain.exponentialRampToValueAtTime(sustainLevel, audioCtx.currentTime + attackTime + decayTime);

            osc.start();

            // Store ref to stop later
            activeOscillators[note] = { osc, noteGain };

            // Visual feedback
            highlightKey(note, true);
        }

        function stopNote(note) {
            if (!audioCtx || !activeOscillators[note]) return;

            const { osc, noteGain } = activeOscillators[note];
            const releaseTime = 0.3;

            // Release
            // Cancel any scheduled updates to avoid conflict
            noteGain.gain.cancelScheduledValues(audioCtx.currentTime);
            // Ramp down
            noteGain.gain.setValueAtTime(noteGain.gain.value, audioCtx.currentTime);
            noteGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + releaseTime);

            osc.stop(audioCtx.currentTime + releaseTime);

            // Cleanup
            setTimeout(() => {
                osc.disconnect();
                noteGain.disconnect();
            }, releaseTime * 1000 + 100);

            delete activeOscillators[note];

            // Visual feedback
            highlightKey(note, false);
        }

        // --- DOM Generation ---

        const pianoContainer = document.getElementById('piano-container');
        const keyMapDOM = {}; // note -> element

        function renderPiano() {
            // White keys take up 1 unit, Black keys overlay them
            // We use flexbox for white keys, absolute for black keys relative to container

            // First, creating a wrapper for proper spacing
            // Let's count white keys to determine width percentages
            const whiteKeyCount = pianoLayout.filter(k => k.type === 'white').length;
            const whiteKeyWidth = 100 / whiteKeyCount;

            let whiteKeyIndex = 0;

            pianoLayout.forEach((keyData) => {
                const keyEl = document.createElement('div');
                keyEl.dataset.note = keyData.note;

                // Label
                const label = document.createElement('span');
                label.className = 'key-label';
                label.innerText = keyData.keyBind.toUpperCase();
                keyEl.appendChild(label);

                // Events
                const startEvent = (e) => { e.preventDefault(); playNote(keyData.note); };
                const endEvent = (e) => { e.preventDefault(); stopNote(keyData.note); };

                // Mouse
                keyEl.addEventListener('mousedown', startEvent);
                keyEl.addEventListener('mouseup', endEvent);
                keyEl.addEventListener('mouseleave', endEvent);

                // Touch
                keyEl.addEventListener('touchstart', startEvent, { passive: false });
                keyEl.addEventListener('touchend', endEvent);
                keyEl.addEventListener('touchcancel', endEvent);

                keyMapDOM[keyData.note] = keyEl;

                if (keyData.type === 'white') {
                    keyEl.className = 'key white-key h-full bg-white border border-gray-300';
                    keyEl.style.width = `${whiteKeyWidth}%`;
                    pianoContainer.appendChild(keyEl);
                    whiteKeyIndex++;
                } else {
                    keyEl.className = 'key black-key h-[60%] bg-black absolute top-0';
                    keyEl.style.width = `${whiteKeyWidth * 0.65}%`; // Black key slightly narrower
                    // Calculate position: Left edge of current white key index minus half black width
                    // The previous loop incremented index, so play catchup
                    // A black key comes AFTER a white key usually (C, C#, D).
                    // Logic: Place it between white key (index-1) and white key (index)
                    // The 'left' should be (index * whiteWidth) - (blackWidth / 2)

                    const positionLeft = (whiteKeyIndex * whiteKeyWidth) - ((whiteKeyWidth * 0.65) / 2);
                    keyEl.style.left = `${positionLeft}%`;
                    pianoContainer.appendChild(keyEl);
                }
            });
        }

        renderPiano();

        // --- Interaction Handling ---

        function highlightKey(note, isActive) {
            const el = keyMapDOM[note];
            if (el) {
                if (isActive) el.classList.add('active');
                else el.classList.remove('active');
            }
        }

        // Keyboard support
        const keyToNote = {};
        pianoLayout.forEach(k => keyToNote[k.keyBind] = k.note);

        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            const key = e.key.toLowerCase();
            if (keyToNote[key]) playNote(keyToNote[key]);
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keyToNote[key]) stopNote(keyToNote[key]);
        });

        // --- Controls ---

        // Waveform
        const waveBtns = document.querySelectorAll('.wave-btn');
        waveBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                // Update UI
                waveBtns.forEach(b => {
                    b.classList.remove('border-[#00f3ff]', 'text-[#00f3ff]', 'shadow-[0_0_10px_#00f3ff]');
                    b.classList.add('text-gray-400', 'border-[#333]');
                });
                btn.classList.add('border-[#00f3ff]', 'text-[#00f3ff]', 'shadow-[0_0_10px_#00f3ff]');
                btn.classList.remove('text-gray-400', 'border-[#333]');

                // Update Engine
                oscillatorType = btn.dataset.wave;
            });
        });
        // Select first by default visually
        document.querySelector('[data-wave="sine"]').click();

        // Volume
        const volSlider = document.getElementById('volume-slider');
        const volDisplay = document.getElementById('vol-display');

        volSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            volDisplay.innerText = `${val}%`;
            if (masterGainNode) {
                masterGainNode.gain.setValueAtTime(val / 100, audioCtx.currentTime);
            }
        });

        // --- Visualizer ---

        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);

            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            analyser.getByteTimeDomainData(dataArray);

            // Fade effect
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#00f3ff';
            canvasCtx.shadowBlur = 10;
            canvasCtx.shadowColor = '#00f3ff';

            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();

            // Fake CPU load just for aesthetics
            if (Math.random() > 0.9) {
                document.getElementById('cpu-load').innerText = Math.floor(Math.random() * 15) + 5;
            }
        }

    </script>
</body>

</html>